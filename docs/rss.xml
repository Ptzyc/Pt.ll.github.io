<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Pt.ll的blog</title><link>https://Ptzyc.github.io/Pt.ll.github.io</link><description>Pt.ll的专属blog</description><copyright>Pt.ll的blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cdn.luogu.com.cn/upload/image_hosting/pnqeub2s.png</url><title>avatar</title><link>https://Ptzyc.github.io/Pt.ll.github.io</link></image><lastBuildDate>Tue, 15 Apr 2025 07:32:55 +0000</lastBuildDate><managingEditor>Pt.ll的blog</managingEditor><ttl>60</ttl><webMaster>Pt.ll的blog</webMaster><item><title>Codeforces 1016E</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/Codeforces%201016E.html</link><description>[题目](https://codeforces.com/problemset/problem/2093/E)
# 思路
对于 $u=MEX(v)$，如果选择数组 $v$ 的一部分组成新数组 $s$ 那么在所有的 $w&lt;u$ 中，能否都能找到 $w=MEX(s)$？

这当然是肯定的，不难想到，我们可以考虑**二分**，下限 $l = 0$，上限 $r=n$（因为数组顶多是 $[0,1, \dots, n-1]$）。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/Codeforces%201016E.html</guid><pubDate>Tue, 15 Apr 2025 07:23:18 +0000</pubDate></item><item><title>Codeforces 1006</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/Codeforces%201006.html</link><description># 在 Print 之前
鄙人早上考了一场 $VP$,但比赛时只拿下了5道题，大概排在全球 $4624$ 位
# A - New World, New Me, New Array
[题目](https://codeforces.com/problemset/problem/2072/A)

也是非常感人的一题，有点贪心的影子，最后模拟一下即可。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/Codeforces%201006.html</guid><pubDate>Sat, 12 Apr 2025 07:03:05 +0000</pubDate></item><item><title>Atcoder Beginner Contest 400</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/Atcoder%20Beginner%20Contest%20400.html</link><description># 在 Print 之前
已经有近一个月没写文章了，这又是一片 $Atcoder$ 的比赛，场A了4道题，~~第五题没改出来~~。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/Atcoder%20Beginner%20Contest%20400.html</guid><pubDate>Sat, 12 Apr 2025 07:00:36 +0000</pubDate></item><item><title>Atcoder Beginner Contest 244</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/Atcoder%20Beginner%20Contest%20244.html</link><description># 在 Print 之前
又是熟悉的 $Atcoder$ 的题解，又是一场熟悉的 $VP$，~~又是熟悉的五道题~~

考试时又不知道在干嘛，~~第一题都错了一次~~， $50min$ 时拿下第五题，但第六题思考了 $50min$ 也没拿下...

~~只是没想到前四题都是红题~~。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/Atcoder%20Beginner%20Contest%20244.html</guid><pubDate>Sat, 12 Apr 2025 06:59:15 +0000</pubDate></item><item><title>AtCoder Beginner Contest 245</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/AtCoder%20Beginner%20Contest%20245.html</link><description># 在 Print 之前
又是 $Atcoder$ 的题解，又是一场 $VP$，~~又是五道题~~

我不知道在比赛时我在干嘛， $T3$ 交了 $6$ 遍才过， $T4$ 交了 $3$ 遍， $T5$ 交了 $5$ 遍才过， $T6$ 因为一点小错误，~~没写出来~~。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/AtCoder%20Beginner%20Contest%20245.html</guid><pubDate>Sat, 12 Apr 2025 06:56:11 +0000</pubDate></item><item><title>差分约束——讲解+例题</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/cha-fen-yue-shu-%E2%80%94%E2%80%94-jiang-jie-%2B-li-ti.html</link><description># 什么是差分约束
$oi-wiki$ 是这样说的：

&gt;差分约束系统 是一种特殊的 n 元一次不等式组，它包含 $n$ 个变量 $x_{1},x_{2},\dots,x_{n}$ 以及 $m$ 个约束条件，每个约束条件是由两个其中的变量做差构成的，形如 $x_{i}-x_{j}\le c_{k}$，其中 $1 \le i, j \le n, i \ne j, 1 \le k \le m$ 并且 $c_{k}$ 是常数（可以是非负数，也可以是负数）。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/cha-fen-yue-shu-%E2%80%94%E2%80%94-jiang-jie-%2B-li-ti.html</guid><pubDate>Sat, 12 Apr 2025 06:51:00 +0000</pubDate></item><item><title>Atcoder Beginner Contest 242</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/Atcoder%20Beginner%20Contest%20242.html</link><description># 在 Print 之前
又是一篇 $Atcoder$ 的题解，星期二(3.4)打了一场 $vp$，赛时做出来了5道，~~第六道赛时觉得太抽象没写出来~~。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/Atcoder%20Beginner%20Contest%20242.html</guid><pubDate>Sat, 12 Apr 2025 06:49:06 +0000</pubDate></item><item><title>Codeforces 241E</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/Codeforces%20241E.html</link><description># 题目
[题目传送门](https://codeforces.com/problemset/problem/241/E)
# 大意
有一个 $n$ 个结点且每条边权值均为 $1$ 的有向图，要你把一些边权改成 $2$ 使得任意一条从 $1$ 到 $n$ 的路径长度都相等。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/Codeforces%20241E.html</guid><pubDate>Sat, 12 Apr 2025 06:46:32 +0000</pubDate></item><item><title>Atcoder Beginner Contest 241</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/Atcoder%20Beginner%20Contest%20241.html</link><description># 在 Print 之前
这是 2.20 打的一场 VP 也是非常感人，~~第四题磕了一个多小时没磕出来~~，最后终于是过了6道题。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/Atcoder%20Beginner%20Contest%20241.html</guid><pubDate>Sat, 12 Apr 2025 06:44:06 +0000</pubDate></item><item><title>基础线段树</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/ji-chu-xian-duan-shu.html</link><description># 前置批注
本文代码中所有的 `ll` 均为 `long long` ， `lt` 均为 `Lazy_tag` 。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/ji-chu-xian-duan-shu.html</guid><pubDate>Sat, 12 Apr 2025 06:35:17 +0000</pubDate></item><item><title>AtCoder Beginner Contest 393</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/AtCoder%20Beginner%20Contest%20393.html</link><description># A-Poisonous Oyster
[题目](https://atcoder.jp/contests/abc393/tasks/abc393_a)

本题很简单，因为 *Takahashi* 吃了1和2，而 *Aoki* 吃了1和3，所以他们都为 *fine* 时，4号就有问题；同理，可以判断那个有问题。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/AtCoder%20Beginner%20Contest%20393.html</guid><pubDate>Sat, 12 Apr 2025 06:33:47 +0000</pubDate></item><item><title>2.13比赛总结</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/2.13-bi-sai-zong-jie.html</link><description># T1
题目：
![](https://i-blog.csdnimg.cn/direct/633cec4b6a494df8ac4f003ea5acbb6f.png)
一道非常简单的模拟，输入之后按照题目操作就行了。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/2.13-bi-sai-zong-jie.html</guid><pubDate>Sat, 12 Apr 2025 06:30:30 +0000</pubDate></item><item><title>访问者须知</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/fang-wen-zhe-xu-zhi.html</link><description> 此 **Blog** 是用来存储鄙人的博客内容的，**请勿攻击或发表不良言论**。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/fang-wen-zhe-xu-zhi.html</guid><pubDate>Thu, 10 Apr 2025 09:28:58 +0000</pubDate></item><item><title>题解：AT_abc245_e [ABC245E] Wrapping Chocolate</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9AAT_abc245_e%20%5BABC245E%5D%20Wrapping%20Chocolate.html</link><description># E - Wrapping Chocolate
[题目](https://atcoder.jp/contests/abc245/tasks/abc245_e)

这题一看就是**贪心**，对于某个物品来说，我们要尽量放到小的箱子里。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9AAT_abc245_e%20%5BABC245E%5D%20Wrapping%20Chocolate.html</guid><pubDate>Thu, 10 Apr 2025 09:18:08 +0000</pubDate></item><item><title>题解：AT_abc242_e [ABC242E] (∀x∀)</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9AAT_abc242_e%20%5BABC242E%5D%20%28%E2%88%80x%E2%88%80%29.html</link><description># E - (∀x∀)
[题目](https://atcoder.jp/contests/abc242/tasks/abc242_e)

~~这题我居然给自己挖了两个坑，还都跳下去了~~

我们考虑回文字符串是如何构成的，是由前面大约 $n \div 2$ 个字符翻转拼接而成。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9AAT_abc242_e%20%5BABC242E%5D%20%28%E2%88%80x%E2%88%80%29.html</guid><pubDate>Thu, 10 Apr 2025 09:14:24 +0000</pubDate></item><item><title>题解：CF241E Flights</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9ACF241E%20Flights.html</link><description># 题目
[题目传送门](https://codeforces.com/problemset/problem/241/E)
# 大意
有一个 $n$ 个结点且每条边权值均为 $1$ 的有向图，要你把一些边权改成 $2$ 使得任意一条从 $1$ 到 $n$ 的路径长度都相等。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9ACF241E%20Flights.html</guid><pubDate>Thu, 10 Apr 2025 09:13:58 +0000</pubDate></item><item><title>题解：AT_abc241_f [ABC241F] Skate</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9AAT_abc241_f%20%5BABC241F%5D%20Skate.html</link><description># Skate

[题目](https://www.luogu.com.cn/problem/AT_abc241_f)

这是一道一眼的 **Bfs** 但单单是搜索就很容易爆 **TLE**。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9AAT_abc241_f%20%5BABC241F%5D%20Skate.html</guid><pubDate>Thu, 10 Apr 2025 09:12:45 +0000</pubDate></item><item><title>题解：AT_abc242_d [ABC242D] ABC Transform</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9AAT_abc242_d%20%5BABC242D%5D%20ABC%20Transform.html</link><description># D - ABC Transform
[题目](https://atcoder.jp/contests/abc242/tasks/abc242_d)

我们不难发现，它每次分裂出两个节点，这是啥，二叉树啊，请看图：
![](https://cdn.luogu.com.cn/upload/image_hosting/uq13mj8o.png)

所以我们只需用一个变量统计一下单复数，左根加 $1$ 右根加 $2$，即：

$$sum = sum + \begin{cases}
1 &amp; k \equiv 1 \pmod 2\\
2 &amp; k \equiv 0 \pmod 2
\end{cases}$$

注意，如果 $60 \le t$ 那么数肯定大于 $10^{18}$。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9AAT_abc242_d%20%5BABC242D%5D%20ABC%20Transform.html</guid><pubDate>Thu, 10 Apr 2025 08:57:21 +0000</pubDate></item><item><title>题解：P7054 [NWRRC2015] Graph</title><link>https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9AP7054%20%5BNWRRC2015%5D%20Graph.html</link><description>[题目传送门](https://www.luogu.com.cn/problem/P7054)
# **题目分析**
题目说的很清楚，如果没有 $k$ 就是纯**拓扑**；

题目说最小的拓扑序的最大，俗称第一位最小，第二位第二小等；这一看就是**贪心**；

虽说知道了大致方向但如何贪又是一个问题；
# **思路**
贪心：对于当前入度为 $0$ 的点，假如有多个，给比较小的点加一个连向它的边，然后选大一点的点。</description><guid isPermaLink="true">https://Ptzyc.github.io/Pt.ll.github.io/post/ti-jie-%EF%BC%9AP7054%20%5BNWRRC2015%5D%20Graph.html</guid><pubDate>Thu, 10 Apr 2025 08:34:07 +0000</pubDate></item></channel></rss>